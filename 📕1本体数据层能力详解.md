# 📕 本体数据层能力详解 - 数据治理与对象建模

> **企业数据的数字孪生** - Data Connection × Ontology Manager × 权限治理 × 审计追踪

**对应工具编号**：03.Data Connection、Ontology Manager、权限系统、Data Lineage
**适合角色**：数据架构师、本体建模师、数据治理经理、合规官
**学习周期**：3-7天

---

## 📑 目录

1. [第1章：核心概念与架构](#第1章-核心概念与架构)
2. [第2章：Data Connection - 多源接入](#第2章-data-connection---多源接入)
3. [第3章：Ontology Manager - 本体建模](#第3章-ontology-manager---本体建模)
4. [第4章：权限体系 - 细粒度控制](#第4章-权限体系---细粒度控制)
5. [第5章：审计追踪 - 数据治理](#第5章-审计追踪---数据治理)
6. [实战案例与最佳实践](#实战案例与最佳实践)

---

## 第1章：核心概念与架构

### 1.1 本体数据层的定位

```
外部源系统（Snowflake/S3/ERP等）
    ↓
Data Connection（多源接入）
    ↓ 数据同步、版本控制
Ontology Manager（业务对象定义）
    ↓ 映射、属性、关系
权限体系（行列级安全）
    ↓ 基于角色、分类、目的
审计追踪（不可变日志）
    ↓ 完整决策历史
下游应用（Workshop、Quiver、Contour）
```

**三个核心要素**：
1. **数据源** - 原始数据的来源地
2. **本体对象** - 业务语言化的数据模型
3. **权限与治理** - 确保数据安全合规

### 1.2 本体数据层 vs 数据变换层的区别

| 维度 | 本体数据层 | 数据变换层 |
|------|----------|----------|
| **职责** | 定义数据模型、管理权限、审计追踪 | 清洗数据、转换逻辑、生成衍生数据 |
| **工具** | Data Connection、Ontology Manager | Pipeline Builder、SQL表达式、Code Repos |
| **输出** | 业务对象类型与权限规则 | 清洁数据集与派生指标 |
| **使用者** | 数据架构师、业务分析师 | 数据工程师、分析师 |
| **变更频率** | 低（季度级） | 高（周级） |

---

## 第2章：Data Connection - 多源接入

### 2.1 核心概念

**Data Connection** 的两个关键组件：
- **Sources（源）**：可交换数据的外部系统
- **Syncs（同步）**：定义数据推拉规则和时间安排

### 2.2 支持的数据源类型

#### 【类型1】关系数据库

```
主流数据库：
├─ 传统：Oracle, SQL Server, PostgreSQL, MySQL
├─ 云数据仓库：Snowflake, Redshift, BigQuery, Databricks
├─ 国产数据库：达梦, 人大金仓, TiDB
└─ 时序数据库：InfluxDB, TimescaleDB

连接特点：
├─ JDBC协议标准化连接
├─ 支持SSL/TLS加密
├─ 自动连接池管理
├─ 版本控制与备份
└─ 多种同步策略
```

#### 【类型2】云存储与文件系统

```
存储服务：
├─ S3（AWS）
│  ├─ 支持分区桶管理
│  ├─ 自动压缩检测（Gzip、Parquet）
│  ├─ 流式读取大文件
│  └─ 跨区域复制策略
├─ ADLS（Azure Data Lake Storage）
│  └─ 与Databricks原生集成
├─ GCS（Google Cloud Storage）
│  └─ 行级安全支持
└─ 本地存储（NFS、HDFS）
   └─ 代理（Agent）模式支持
```

#### 【类型3】SaaS与API

```
SaaS应用：
├─ CRM：Salesforce, HubSpot, Pipedrive
├─ 电商：Shopify, WooCommerce
├─ 办公：Slack, Microsoft 365
├─ 金融：Stripe, Square, Plaid
├─ ERP：SAP, Oracle NetSuite, 用友
└─ 通讯：Twilio, SendGrid

API连接类型：
├─ REST API（标准化）
├─ GraphQL（复杂查询）
├─ Webhook（事件推送）
└─ 专有协议（Salesforce SOAP等）
```

### 2.3 同步策略详解

#### 策略1：快照同步（Snapshot）

```
特点：
├─ 完整复制源数据
├─ 每次覆盖旧数据
├─ 适合维度表（小、变化慢）
└─ 示例：产品目录、部门组织结构

配置示例：
【UI操作】
├─ 1. 选择表：PRODUCTS
├─ 2. 同步模式：Snapshot
├─ 3. 调度：每天 02:00 UTC
├─ 4. 保留版本：最近10个
└─ 5. 运行测试

性能指标：
├─ 首次同步：5分钟（100万行）
├─ 后续同步：3分钟（数据覆盖）
└─ 存储空间：基础 + 10个版本副本
```

#### 策略2：增量同步（Incremental）

```
特点：
├─ 仅传输新增/更新数据
├─ 基于时间戳或序列号标识
├─ 适合事实表（大、快速增长）
└─ 示例：订单表、日志表

配置示例：
【UI操作】
├─ 1. 选择表：ORDERS
├─ 2. 同步模式：Incremental
├─ 3. 增量列：UPDATED_AT（时间戳）
├─ 4. 首次同步：全量（2024-01-01之后）
├─ 5. 后续同步：每小时
│  ├─ 查询：WHERE UPDATED_AT > @last_sync_time
│  ├─ 自动记录最后同步时间
│  └─ 下次同步从该时间继续
├─ 6. 冲突处理：UPSERT（有则更新，无则插入）
└─ 7. 告警规则：同步耗时>30分钟时告警

首次同步详情：
├─ Foundry → ORDERS 表查询
├─ 读取 50M 行数据
├─ 耗时：约 12 分钟
├─ 生成数据集：orders_v0
└─ 记录 checkpoint：2024-01-16 08:00 UTC

后续增量同步（每小时）：
├─ 查询：SELECT * FROM ORDERS
│        WHERE UPDATED_AT > '2024-01-16 08:00'
├─ 结果：新增5000行，修改3000行
├─ 合并策略：
│  ├─ 新增行 → 直接插入
│  ├─ 修改行 → 按主键更新
│  └─ 删除行 → 标记 is_deleted=1
├─ 完成时间：30秒
└─ 更新 checkpoint：2024-01-16 09:00 UTC

数据质量检查：
├─ 检查NULL值比例
├─ 验证主键唯一性
├─ 对比前后行数趋势
└─ 异常时自动告警
```

#### 策略3：CDC同步（Change Data Capture）

```
特点：
├─ 实时流式同步
├─ 捕获所有数据变化（INSERT/UPDATE/DELETE）
├─ 适合高频关键指标
├─ 延迟 <1秒
└─ 示例：实时交易、库存

CDC实施架构：
源数据库（如MySQL binlog）
    ↓ CDC组件识别变化
    ├─ INSERT 事件
    ├─ UPDATE 事件
    └─ DELETE 事件
    ↓ 写入中间队列（Kafka）
Kafka Topic（ORDERS-CDC）
    ├─ Partition 1: East Region Orders
    ├─ Partition 2: West Region Orders
    └─ Partition 3: Reconciliation
    ↓ Foundry Stream Connector 消费
Foundry 实时数据集
    ├─ 立即可查询
    ├─ 支持聚合计算
    └─ 触发下游规则

配置示例：
├─ 1. 源系统：MySQL（二进制日志启用）
├─ 2. CDC工具：Debezium（开源）或原生CDC
├─ 3. 消息队列：Kafka
├─ 4. Foundry配置：
│  ├─ Connector 类型：Kafka Stream
│  ├─ Topic：mysql.production.orders
│  ├─ 消费策略：从最新偏移量开始
│  ├─ 解析格式：Avro（含schema）
│  └─ 错误处理：失败重试+死信队列
└─ 5. 性能监控
   ├─ 消费延迟：通常<500ms
   ├─ 吞吐量：10万条/秒
   └─ 数据完整性：99.99%

业务影响：
├─ 库存实时显示（不是1小时前的数据）
├─ 风险实时预警
├─ 价格实时更新
└─ 成本相比增量同步高30%（但实时性无法比较）
```

### 2.4 实战案例：构建多源数据集成

**业务场景**：零售企业需要从5个不同系统获取订单、客户、库存数据

```
【第1步】需求分析

数据源盘点：
├─ 系统1：Oracle ERP（订单系统）
│  ├─ 表：ORDERS（5千万行/年）、ORDER_ITEMS（1.5亿行/年）
│  ├─ 更新频率：每笔订单实时写入
│  ├─ 关键字段：order_id, customer_id, amount, status, created_at, updated_at
│  ├─ 网络位置：内网（需代理）
│  └─ 数据质量：95%（有脏数据）
│
├─ 系统2：Salesforce CRM（客户信息）
│  ├─ 对象：Account（客户）、Contact（联系人）
│  ├─ 更新频率：每天800个变更
│  ├─ 关键字段：account_id, name, industry, revenue, contact_email
│  ├─ 连接方式：REST API
│  └─ 速率限制：100请求/秒
│
├─ 系统3：AWS S3（库存数据）
│  ├─ 文件格式：Parquet分区表
│  ├─ 路径：s3://inventory-bucket/year=2024/month=01/
│  ├─ 更新频率：每天凌晨2点完整覆盖
│  ├─ 数据量：20GB/月
│  └─ 网络：公网可访问
│
├─ 系统4：MySQL（日志数据）
│  ├─ 表：events（日志事件）
│  ├─ 数据量：100GB+
│  ├─ 更新频率：1000条/秒（流式）
│  ├─ 关键字段：event_id, customer_id, event_type, timestamp
│  └─ 网络：VPC内网
│
└─ 系统5：Stripe API（支付数据）
   ├─ 端点：/v1/subscriptions
   ├─ 更新频率：每笔支付实时
   ├─ 数据量：250万订阅
   └─ 认证方式：Bearer Token

同步策略决策矩阵：
┌─────────────┬────────┬──────────┬────────────┐
│ 源系统      │ 数据量 │ 变化频率 │ 推荐策略   │
├─────────────┼────────┼──────────┼────────────┤
│ Oracle ERP  │ 超大   │ 实时     │ CDC+增量   │
│ Salesforce  │ 小     │ 低       │ 快照       │
│ AWS S3      │ 中     │ 日      │ 增量       │
│ MySQL       │ 超大   │ 实时     │ 流式       │
│ Stripe      │ 中     │ 实时     │ 增量+告警  │
└─────────────┴────────┴──────────┴────────────┘

【第2步】Data Connection配置

配置1：Oracle ERP
├─ 创建 Source → 选择"Oracle Database"
├─ 连接参数：
│  ├─ Host: erp.internal.company.com:1521
│  ├─ SID: ERPDB
│  ├─ User: foundry_sync_user
│  └─ Password: 从密钥管理器获取
├─ 网络配置：
│  ├─ 部署 Agent（在公司VPN内）
│  ├─ Agent 地址：10.0.1.50:8080
│  └─ Agent 定期轮询 Foundry 的指令
├─ 表同步配置：
│  ├─ ORDERS：
│  │  ├─ 首次同步：2024-01-01 之后的全量
│  │  ├─ 增量字段：updated_at
│  │  ├─ 调度：每小时增量同步
│  │  ├─ 过滤条件：status != 'CANCELLED'
│  │  └─ 版本保留：7天历史
│  └─ ORDER_ITEMS：
│     ├─ 同上配置
│     └─ 关联字段：order_id
└─ 测试同步 → 部署

配置2：Salesforce CRM
├─ 创建 Source → 选择"Salesforce"
├─ OAuth认证：
│  ├─ 授权 Foundry 访问 Salesforce
│  ├─ 选择权限范围：Account、Contact 对象
│  └─ 自动刷新 token
├─ 对象同步配置：
│  ├─ Account（快照）：
│  │  ├─ 调度：每天 03:00 UTC
│  │  ├─ 字段映射：
│  │  │  ├─ Id → account_id
│  │  │  ├─ Name → account_name
│  │  │  ├─ Industry → industry
│  │  │  └─ AnnualRevenue → annual_revenue
│  │  └─ 行级过滤：RecordType = 'Customer'
│  └─ Contact（快照）：
│     └─ 类似配置
└─ 创建关系：Account.Id = Account__r (Contact 的查找字段)

配置3：AWS S3
├─ 创建 Source → 选择"AWS S3"
├─ 认证方式：IAM Role（推荐）
│  ├─ Role ARN：arn:aws:iam::123456:role/FoundryRead
│  ├─ 权限：s3:GetObject on inventory-bucket/*
│  └─ 信任关系：允许 Foundry 账户 assume role
├─ 数据配置：
│  ├─ Bucket：inventory-bucket
│  ├─ 路径：s3://inventory-bucket/year=*/month=*/
│  ├─ 文件格式：Parquet
│  ├─ 分区识别：year, month
│  ├─ 压缩：snappy
│  └─ 调度：每天 08:00 UTC
└─ 性能优化：
   ├─ 并行读取：12 个线程
   └─ 块大小：128MB

配置4：MySQL Stream
├─ 创建 Source → 选择"MySQL with CDC"
├─ 连接配置：
│  ├─ Host: mysql.internal.vpc:3306
│  ├─ User: cdc_user
│  ├─ Database: events_db
│  └─ 需要部分权限：BINLOG, SELECT
├─ CDC配置：
│  ├─ 二进制日志格式：ROW
│  ├─ 保留时间：7天
│  ├─ Debezium 部署（Docker）
│  ├─ Kafka 主题：mysql-cdc.events.events
│  └─ 消费起点：Latest
├─ 事件处理：
│  ├─ INSERT 事件 → 直接写入
│  ├─ UPDATE 事件 → 按 event_id 更新
│  ├─ DELETE 事件 → 标记 is_deleted
│  └─ 错误处理：失败重试 5 次
└─ 监控告警：
   ├─ 消费延迟 >1秒 → 告警
   └─ 事件丢失 → 紧急告警

配置5：Stripe API
├─ 创建 Source → 选择"REST API"
├─ API 配置：
│  ├─ 基础 URL：https://api.stripe.com/v1
│  ├─ 端点：/subscriptions
│  ├─ 认证：Bearer Token（从密钥管理器获取）
│  └─ 请求头：User-Agent: Foundry/2.0
├─ 分页配置：
│  ├─ 类型：Cursor-based
│  ├─ 光标字段：starting_after
│  ├─ 每页数：100
│  └─ 停止条件：has_more = false
├─ 增量配置：
│  ├─ 时间戳字段：created
│  ├─ 查询参数：?created[gte]={last_sync}
│  └─ 调度：每 30 分钟
├─ 速率限制处理：
│  ├─ Stripe 限制：100 req/s
│  ├─ Foundry 自动限流
│  └─ 失败指数退避
└─ 错误处理：
   ├─ 网络失败 → 重试 3 次
   ├─ API 故障 → 延迟至下次运行
   └─ 数据异常 → 隔离+告警

【第3步】版本控制与回滚

Version History Management：
├─ 每次同步产生一个版本快照
├─ ORDERS 版本时间线：
│  ├─ v1：2024-01-01 08:00
│  ├─ v2：2024-01-02 08:00
│  ├─ v3：2024-01-03 08:00（包含数据问题）
│  └─ v4：2024-01-04 08:00
├─ 发现问题后可以回滚：
│  ├─ 对比 v3 和 v2：发现多出 500 条异常订单
│  ├─ 根因分析：ERP 系统夜间批处理异常
│  ├─ 决策：回滚至 v2（排除异常数据）
│  └─ 临时冻结 v3，等待 ERP 修复后重新同步
└─ 完整审计日志：
   ├─ 谁执行的回滚
   ├─ 何时回滚
   ├─ 影响范围
   └─ 业务理由

【第4步】健康检查与监控

监控仪表盘（Foundry UI）：
┌────────────────────────────────┐
│ 📊 Data Connection Health       │
├────────────────────────────────┤
│ ✅ Oracle ERP                  │
│   └─ Last Sync: 2024-01-16 09:00
│   └─ Status: Success            │
│   └─ Rows: 5.2M → 5.25M (+50k)  │
│                                 │
│ ✅ Salesforce CRM              │
│   └─ Last Sync: 2024-01-16 03:00
│   └─ Status: Success            │
│   └─ Rows: 102k → 102.8k (+800) │
│                                 │
│ ⚠️  MySQL Events (CDC)          │
│   └─ Last Event: 2024-01-16 09:14
│   └─ Status: Running            │
│   └─ Lag: 45ms ✓ (threshold: 1s)│
│   └─ Throughput: 850 events/s   │
│                                 │
│ ⚠️  AWS S3 Inventory            │
│   └─ Last Sync: 2024-01-16 08:00
│   └─ Status: Success            │
│   └─ Rows: 2.1M                 │
│   └─ Size: 1.8GB                │
│                                 │
│ ✅ Stripe Subscriptions         │
│   └─ Last Sync: 2024-01-16 09:30
│   └─ Status: Success            │
│   └─ Rows: 2.5M                 │
└────────────────────────────────┘

告警规则配置：
├─ 规则1：同步失败
│  ├─ 条件：任何 Source 同步失败
│  ├─ 告警：立即发送 Slack
│  └─ 升级：1小时未恢复 → 发送 Email
├─ 规则2：数据异常
│  ├─ 条件：新增行数 > 前日 150% OR < 前日 50%
│  ├─ 告警：发送 Slack + 通知数据团队
│  └─ 示例：本日 ORDERS 新增 500k 行（前日 50k）
├─ 规则3：性能告警
│  ├─ 条件：同步耗时 > 30 分钟
│  ├─ 告警：记录日志 + 趋势分析
│  └─ 示例：Oracle 同步从 8 分钟增至 25 分钟
└─ 规则4：数据质量
   ├─ 条件：NULL 值比例 > 10% 或重复率 > 1%
   ├─ 告警：发送数据质量报告
   └─ 示例：customer_id 字段 12% 为 NULL
```

---

## 第3章：Ontology Manager - 本体建模

### 3.1 核心概念

**本体（Ontology）**是 Foundry 的核心创新，它将**原始数据**转换为**业务对象**：

```
原始数据集
├─ ORDERS 表（50M 行）
├─ 字段：order_id, customer_id, amount, status, ...
└─ 技术语言：行、列、类型

        ↓ 映射 (Mapping)

业务对象 (Ontology Object)
├─ Order 对象类型
├─ 属性：id, customer, amount, status, ...
├─ 动作：Assign, Escalate, Cancel
├─ 链接：Order → Customer, Product
└─ 业务语言：客户能理解的对象模型
```

### 3.2 本体的四个核心元素

#### 元素1：对象类型（Object Types）

```
对象类型定义示例（Order 订单）：

【基本信息】
├─ 名称：Order
├─ 显示名称：订单
├─ 复数形式：Orders
├─ 描述：客户订单记录
└─ 图标：🛒

【主键配置】
├─ Primary Key：order_id
├─ Display Key：orderNumber（用于UI展示）
│  └─ 例：显示 "ORD-20240116-001" 而非 "123456"
└─ Title Template：Order {orderNumber} from {customer.name}

【关键属性】
├─ 基础属性：
│  ├─ order_id: String (UUID)
│  ├─ orderNumber: String (业务单号)
│  ├─ createdAt: DateTime
│  ├─ amount: Double (金额，单位：元)
│  ├─ status: Enum (PENDING/CONFIRMED/SHIPPED/DELIVERED/CANCELLED)
│  ├─ priority: Enum (LOW/NORMAL/HIGH/URGENT)
│  └─ notes: String (备注)
│
├─ 派生属性（自动计算）：
│  ├─ daysInProgress: Integer
│  │  └─ 计算：(NOW() - createdAt).days
│  ├─ isOverdue: Boolean
│  │  └─ 条件：daysInProgress > 5
│  ├─ isHighValue: Boolean
│  │  └─ 条件：amount > 10000
│  └─ completionPercentage: Double
│     └─ 计算：基于 status 的进度
│
└─ 链接属性（指向其他对象）：
   ├─ customer: Link to Customer
   │  ├─ 关系类型：Many-to-One
   │  ├─ 反向链接：Customer.orders[]
   │  └─ 是否必填：是
   ├─ items: Link to OrderItem[]
   │  ├─ 关系类型：One-to-Many
   │  └─ 级联删除：是
   └─ assignedTo: Link to User
      ├─ 关系类型：Many-to-One
      └─ 是否必填：否

【权限配置】
├─ 对象级权限：谁能看到 Order 对象
│  ├─ 销售团队：可查看自己分配的订单
│  ├─ 财务部：可查看所有订单
│  └─ 一般员工：不可见
├─ 属性级权限：
│  ├─ amount（金额）：仅财务和管理层可见
│  ├─ notes（备注）：可见但不可编辑
│  └─ customer（客户信息）：全员可见
└─ 行级权限：
   ├─ 销售代表 A：仅看自己负责的订单
   ├─ 区域经理：看区域内所有订单
   └─ CEO：看全部订单
```

#### 元素2：属性（Properties）

```
属性类型详解：

1. 基础属性（Primitive）
   ├─ String：文本
   ├─ Integer：整数
   ├─ Double：浮点数
   ├─ Boolean：真/假
   ├─ DateTime：日期时间
   ├─ Date：日期
   ├─ Time：时间
   ├─ Enum：枚举（固定选项）
   └─ JSON：复杂结构

2. 计算属性（Derived）
   ├─ 来自基础属性的计算
   ├─ 示例：age = YEAR(NOW()) - birthYear
   ├─ 示例：fullName = firstName + " " + lastName
   └─ 特点：只读、自动更新

3. 链接属性（Link）
   ├─ Many-to-One（多对一）
   │  └─ 多个Order → 同一个Customer
   ├─ One-to-Many（一对多）
   │  └─ 一个Order ← 多个OrderItem
   ├─ Many-to-Many（多对多）
   │  └─ 多个Order ← 多个Product
   └─ One-to-One（一对一）
      └─ 一个User ← 一个UserProfile

4. 嵌入属性（Embedded）
   ├─ 嵌入其他对象的属性
   ├─ 示例：Address { street, city, zip }
   └─ 特点：无单独 ID，作为父对象的一部分

5. 向量属性（Vector/Embedding）
   ├─ 用于语义搜索
   ├─ 由 AI 模型生成（如 OpenAI Ada）
   ├─ 示例：productDescription 的向量表示
   └─ 用途：RAG 检索、相似度匹配

【属性配置示例】：Order.amount
├─ 名称：amount
├─ 类型：Double
├─ 显示名称：订单金额
├─ 单位：元 (CNY)
├─ 必填：是
├─ 范围验证：0.01 ≤ amount ≤ 1000000
├─ 小数位：2
├─ 权限：
│  ├─ 可见性：所有人
│  ├─ 编辑性：仅财务部
│  └─ 审计：记录所有修改
└─ 显示格式：¥{amount:,.2f}
```

#### 元素3：动作类型（ActionTypes）

```
ActionType 定义订单操作行为：

动作1：分配（Assign）
├─ 参数：
│  ├─ assignedTo（销售代表）：必填，Link to User
│  ├─ reason（分配原因）：可选，String
│  └─ deadline（交付期限）：可选，Date
├─ 前置条件（Pre-condition）：
│  ├─ order.status 必须为 CONFIRMED
│  ├─ order.assignedTo 为空（未分配）
│  └─ assignedTo 必须是销售团队成员
├─ 后置动作（Post-action）：
│  ├─ 更新 order.status = ASSIGNED
│  ├─ 更新 order.assignedAt = NOW()
│  ├─ 发送邮件通知销售代表
│  ├─ 创建任务：[销售代表] 需在 deadline 前完成
│  └─ 记录审计日志
└─ 权限：只有销售经理可执行

动作2：升级（Escalate）
├─ 参数：
│  ├─ escalationLevel（升级级别）：Enum (REGIONAL / NATIONAL / VIP)
│  ├─ reason（升级原因）：String
│  └─ estimatedTime（预计处理时间）：Integer (小时)
├─ 前置条件：
│  ├─ order.priority ≠ URGENT（未升级过）
│  └─ order.status 在 (PENDING, CONFIRMED, ASSIGNED)
├─ 后置动作：
│  ├─ 更新 order.priority = URGENT
│  ├─ 分配给更高级的处理团队
│  ├─ 通知相关经理
│  └─ 标记为"需要立即关注"
└─ 权限：任何销售人员可执行

动作3：取消（Cancel）
├─ 参数：
│  ├─ cancelReason（取消原因）：Enum (CUSTOMER_REQUEST / PAYMENT_FAILED / OUT_OF_STOCK)
│  ├─ refundAmount（退款金额）：Double（默认=订单金额）
│  ├─ needsApproval（是否需要审批）：Boolean
│  └─ approverNotes（审批意见）：String
├─ 前置条件：
│  ├─ order.status 不能是 SHIPPED/DELIVERED/CANCELLED
│  ├─ 如果 needsApproval=true，需经理审批
│  └─ 退款金额 ≤ 订单原始金额
├─ 后置动作：
│  ├─ 更新 order.status = CANCELLED
│  ├─ 创建退款交易记录
│  ├─ 更新库存（如已预留）
│  ├─ 发送取消确认邮件给客户
│  ├─ 触发风险系统（标记风险客户）
│  └─ 记录完整的取消历史
└─ 权限：销售代表可自助取消，金额>5万需经理批准

【UI中的 Action 展示】
Order 对象表中：
├─ 行1：Order #ORD-001
│  ├─ 按钮栏：
│  │  ├─ [分配] - 绿色（可执行）
│  │  ├─ [升级] - 蓝色（可执行）
│  │  └─ [取消] - 红色（可执行）
│  ├─ 点击 [分配] → 弹出对话框
│  │  ├─ 销售代表选择器
│  │  ├─ 分配原因输入框
│  │  ├─ 期限日期选择器
│  │  └─ 确认按钮
│  └─ 执行后：
│     ├─ 订单状态变更为 ASSIGNED
│     ├─ 表格刷新显示新状态
│     ├─ 销售代表收到通知
│     └─ 审计日志记录操作
└─ 行2：Order #ORD-002
   ├─ 按钮栏：
   │  ├─ [分配] - 灰色（不可执行，原因：已分配）
   │  ├─ [升级] - 蓝色
   │  └─ [取消] - 灰色（不可执行，原因：已发货）
```

#### 元素4：条件格式化（Conditional Formatting）

```
规则1：订单优先级着色
├─ 条件：order.priority = 'URGENT'
├─ 格式：背景红色 + 红色文字 + 感叹号图标
├─ 示例行：
│  [🚨] ORD-20240116-015 | 客户A | ¥50000 | 待处理 | (红色背景)

规则2：订单完成状态
├─ 条件1：order.status = 'DELIVERED'
│  ├─ 格式：绿色背景 + ✓ 符号
│  └─ 示例：✓ ORD-20240116-001 (绿色)
├─ 条件2：order.isOverdue = true
│  ├─ 格式：黄色背景 + ⚠️ 警告图标
│  └─ 示例：⚠️ ORD-20240116-005 (黄色)
└─ 条件3：order.status = 'CANCELLED'
   ├─ 格式：灰色背景 + 删除线
   └─ 示例：~~ORD-20240116-003~~ (灰色)

规则3：高价值订单标记
├─ 条件：order.isHighValue = true （amount > 10000）
├─ 格式：金色背景 + ⭐ 星标
└─ 示例：⭐ ORD-20240116-020 | 大客户 | ¥125000 (金色)

规则4：文本内容条件格式
├─ 条件：order.notes CONTAINS '紧急'
├─ 格式：字体加粗 + 下划线
└─ 示例：**订单备注** (下划线)

【UI效果展示】
┌────────────────────────────────────────────────────┐
│ 订单列表                                           │
├────────────────────────────────────────────────────┤
│ 🚨 ORD-001  | 客户A | ¥50000  | 待处理    (红色)  │
│ ✓  ORD-002  | 客户B | ¥8000   | 已交付    (绿色)  │
│ ⚠️  ORD-003  | 客户C | ¥15000  | 待审批    (黄色)  │
│ ⭐ ORD-004  | VIP客户| ¥100000 | 待分配    (金色)  │
│ ~~ ORD-005 ~| 客户E | ¥5000   | 已取消    (灰色)  │
└────────────────────────────────────────────────────┘
```

### 3.3 本体建模实战案例

**场景**：电商平台需要构建完整的业务本体

```
【第1步】业务分析与对象识别

核心业务对象：
├─ 物理对象：
│  ├─ Customer（客户）
│  ├─ Product（产品）
│  ├─ Store（门店）
│  └─ Supplier（供应商）
├─ 交易对象：
│  ├─ Order（订单）
│  ├─ OrderItem（订单行项）
│  ├─ Payment（支付）
│  ├─ Refund（退款）
│  └─ Shipment（发货）
└─ 运营对象：
   ├─ Inventory（库存）
   ├─ Review（评价）
   ├─ Promotion（促销）
   └─ Return（退货）

对象关系图：
┌─────────────┐
│  Customer   │──┐
└─────────────┘  │
                  ├──→ ┌─────────┐
┌─────────────┐  │    │  Order  │
│  Promotion  │──┤    └─────────┘
└─────────────┘  │         │
                  │         ├──→ OrderItem ──┐
┌─────────────┐  │         │                  │
│   Store     │──┤         ├──→ Payment       ├──→ Product
└─────────────┘  │         │                  │
                  │         └──→ Shipment     │
┌──────────────┐ │                           │
│  Supplier    │─┴──────────────────────────→┘
└──────────────┘

Inventory ←── Product
Review ←── Customer + Product
Return ←── Order + OrderItem
```

【第2步】对象详细定义

对象1：Customer（客户）
├─ 属性：
│  ├─ customerId (PK): String
│  ├─ name: String
│  ├─ email: String
│  ├─ phone: String
│  ├─ segment: Enum (BASIC/PREMIUM/VIP)
│  ├─ lifetime Value: Double (派生)
│  ├─ totalOrders: Integer (派生)
│  ├─ lastOrderDate: Date (派生)
│  └─ isActive: Boolean (派生)
├─ 链接：
│  ├─ orders: Order[]
│  ├─ reviews: Review[]
│  └─ preferredStore: Store
└─ 动作：
   ├─ UpdateProfile（更新资料）
   ├─ UpgradeSegment（升级等级）
   └─ DisableAccount（禁用账户）

对象2：Order（订单）
├─ 属性：
│  ├─ orderId (PK): String
│  ├─ orderNumber: String
│  ├─ customer: Link to Customer
│  ├─ createdAt: DateTime
│  ├─ totalAmount: Double
│  ├─ status: Enum (PENDING/CONFIRMED/PROCESSING/SHIPPED/DELIVERED/CANCELLED)
│  ├─ paymentStatus: Enum (UNPAID/PAID/REFUNDED)
│  ├─ priority: Enum (NORMAL/EXPRESS/URGENT)
│  ├─ daysInProgress: Integer (派生)
│  ├─ isOverdue: Boolean (派生)
│  └─ completionRate: Double (派生)
├─ 链接：
│  ├─ items: OrderItem[]
│  ├─ payments: Payment[]
│  ├─ shipments: Shipment[]
│  ├─ returns: Return[]
│  ├─ assignedTo: User
│  └─ store: Store
└─ 动作：
   ├─ Assign（分配）
   ├─ Escalate（升级）
   ├─ Cancel（取消）
   ├─ ProcessPayment（处理支付）
   └─ GenerateShipment（生成发货）

对象3：Product（产品）
├─ 属性：
│  ├─ productId (PK): String
│  ├─ sku: String
│  ├─ name: String
│  ├─ category: String
│  ├─ price: Double
│  ├─ cost: Double
│  ├─ margin: Double (派生)
│  ├─ stock: Integer
│  ├─ minStock: Integer
│  ├─ isLowStock: Boolean (派生)
│  ├─ rating: Double (派生)
│  └─ popularity: Integer (派生)
├─ 链接：
│  ├─ supplier: Supplier
│  ├─ reviews: Review[]
│  ├─ orderItems: OrderItem[]
│  ├─ inventories: Inventory[]
│  └─ promotions: Promotion[]
└─ 动作：
   ├─ UpdatePrice（调整价格）
   ├─ AdjustStock（调整库存）
   └─ MarkOutOfStock（标记缺货）

【第3步】发布本体

发布流程：
├─ 1. 设计阶段：
│  ├─ 业务部门验收对象定义
│  ├─ 数据团队验证数据源映射
│  └─ 安全团队检查权限规则
├─ 2. 开发环境测试：
│  ├─ 生成示例数据
│  ├─ 验证派生属性计算逻辑
│  ├─ 测试动作的前置条件
│  └─ 权限检查（各角色可见性）
├─ 3. 用户验收测试（UAT）：
│  ├─ 销售团队测试订单对象
│  ├─ 财务部门测试支付对象
│  ├─ 仓库部门测试库存对象
│  └─ 收集反馈并调整
└─ 4. 生产发布：
   ├─ 版本标记：v1.0
   ├─ 发布说明：支持对象 10 个，动作 25 个
   ├─ 向所有用户发送通知
   └─ 监控用户反馈与性能指标
```

---

## 第4章：权限体系 - 细粒度控制

### 4.1 权限模型

Foundry 的权限基于**三个维度**：

```
维度1：基于角色 (Role-Based Access Control)
├─ 管理员：全部权限
├─ 分析师：查看、创建应用
├─ 操作员：执行操作、录入数据
└─ 查看者：仅查看

维度2：基于分类 (Classification-Based)
├─ Public（公开）
├─ Internal（内部）
├─ Confidential（机密）
└─ Secret（秘密）

维度3：基于目的 (Purpose-Based)
├─ BusinessAnalysis（商业分析）
├─ OperationalDecision（运营决策）
├─ ComplianceAudit（合规审计）
└─ FinancialReporting（财务报告）
```

### 4.2 权限规则示例

```
规则1：销售数据访问

ROLE: Sales Representative（销售代表）
├─ 可查看的订单：
│  └─ WHERE assigned_to = @current_user OR status = 'PUBLIC'
├─ 可编辑的字段：
│  ├─ status（订单状态）
│  ├─ notes（备注）
│  └─ priority（优先级）
├─ 可执行的动作：
│  ├─ Assign（分配给自己）
│  ├─ Escalate（升级）
│  └─ Cancel（取消）
└─ 不可见的字段：
   ├─ cost（成本）
   ├─ margin（利润率）
   └─ internalNotes（内部备注）

规则2：财务数据访问

ROLE: Finance Manager（财务经理）
├─ 可查看的所有订单（全部）
├─ 可查看的字段：
│  ├─ 所有字段（包括成本）
│  ├─ 支付状态
│  └─ 发票信息
├─ 可执行的动作：
│  ├─ ApproveRefund（批准退款）
│  ├─ GenerateInvoice（生成发票）
│  └─ ProcessPayment（处理支付）
└─ 不可执行的动作：
   ├─ Cancel（不能取消订单）
   └─ AssignOrder（不能分配订单）

规则3：供应商查看权限

ROLE: Supplier Account（供应商账户）
├─ 仅可查看与其相关的产品
├─ 仅可查看包含其产品的订单
├─ 可查看的字段：
│  ├─ 订单状态
│  ├─ 商品数量
│  ├─ 交付地址
│  └─ 订单备注
└─ 不可见的字段：
   ├─ 订单价格
   ├─ 客户信息
   ├─ 其他供应商的产品
   └─ 财务信息
```

---

## 第5章：审计追踪 - 数据治理

### 5.1 审计日志

```
审计日志记录所有数据操作：

记录1：订单更新
{
  "timestamp": "2024-01-16 09:30:45 UTC",
  "operation": "UPDATE",
  "object_type": "Order",
  "object_id": "ORD-20240116-001",
  "user": "sales_rep@company.com",
  "changes": {
    "status": "PENDING → ASSIGNED",
    "assigned_to": "null → sales_rep@company.com",
    "assigned_at": "null → 2024-01-16 09:30:45"
  },
  "action": "Assign",
  "reason": "分配给资深销售代表处理",
  "result": "SUCCESS",
  "impact": "Customer notification sent"
}

记录2：权限变更
{
  "timestamp": "2024-01-16 10:00:00 UTC",
  "operation": "PERMISSION_CHANGE",
  "object": "Order",
  "user": "admin@company.com",
  "change": "Sales team: added view permission on cost field",
  "reason": "为提高透明度，销售团队可查看成本",
  "affected_users": 45
}

记录3：数据导出
{
  "timestamp": "2024-01-16 10:15:30 UTC",
  "operation": "EXPORT",
  "dataset": "orders_january",
  "user": "analyst@company.com",
  "export_format": "CSV",
  "rows_exported": 10000,
  "fields": ["order_id", "customer", "amount", "status"],
  "destination": "analyst_local_drive",
  "purpose": "FinancialReporting"
}
```

### 5.2 Data Lineage（数据血缘）

```
完整数据链路可视化：

Snowflake ORDERS 表
    ↓ Data Connection (Sync: Incremental, 每小时)
Foundry orders_raw 数据集
    ↓ Pipeline (Filter, Join, Aggregate)
Foundry orders_processed 数据集
    ↓ Ontology Mapping
Order 业务对象
    ↓ Workshop 应用
销售仪表盘
    ↓ 销售代表查看并执行 Assign 动作
操作记录写回
    ↓ 触发下游 Pipeline
自动通知系统
    ↓ 邮件、Slack 通知

影响分析示例：
如果修改"Order.amount"字段的权限规则（改为仅财务可见）：
├─ 影响范围：
│  ├─ 所有依赖此字段的应用（15 个）
│  ├─ 所有包含此字段的报表（32 个）
│  ├─ 所有引用此字段的 Pipeline（8 个）
│  └─ 受影响的用户（500+ 销售代表）
├─ 变更前审批：需数据治理委员会审批
└─ 变更后通知：发送邮件给所有受影响的用户
```

---

## 实战案例与最佳实践

### 案例1：金融风控系统

```
【业务需求】
- 实时监控客户风险评分
- 支持多维度风险分析
- 完整的决策审计追踪
- 满足 SOX 合规要求

【架构设计】

数据源层：
├─ Oracle 核心业务系统（Agent 连接）
├─ Salesforce CRM（API 连接）
├─ 彭博社市场数据（流式连接）
└─ 内部风险评分模型（输出）

↓

本体数据层：
├─ Customer 对象
│  ├─ 风险评分（派生属性）
│  └─ 是否高风险（派生）
├─ RiskAssessment 对象
│  ├─ 评估时间
│  ├─ 风险因子
│  └─ 评估结果
└─ RiskAction 对象
   ├─ 降低额度
   ├─ 冻结账户
   └─ 转人工审核

↓

权限体系：
├─ 风险分析师：查看所有风险数据
├─ 业务主管：查看本部门数据
├─ 合规官员：查看完整审计日志
└─ 普通员工：仅查看公开数据

↓

审计追踪：
└─ 所有风险决策记录在案

【实施成果】
- 风险识别速度提升 10 倍
- 误报率降低 60%
- 审计合规性 100%
```

### 最佳实践

```
实践1：本体模型设计
✅ 从业务需求出发，而非技术导向
✅ 充分的业务部门参与
✅ 渐进式扩展（先核心，后扩展）
✅ 定期审查和优化

实践2：权限管理
✅ 遵循最小权限原则
✅ 定期审计权限规则
✅ 建立权限审批流程
✅ 记录权限变更原因

实践3：数据质量
✅ 在源头进行数据验证
✅ 建立数据质量规则
✅ 定期数据审计报告
✅ 问题及时上报和解决

实践4：审计与治理
✅ 保存不可变审计日志
✅ 定期生成合规报告
✅ 支持数据溯源查询
✅ 建立数据治理委员会
```

---

## 总结与下一步

### 关键要点

✅ **本体数据层**是 Foundry 的基础，定义业务模型
✅ **Data Connection** 安全可靠地接入多源数据
✅ **Ontology Manager** 将技术数据转为业务语言
✅ **权限与审计** 确保企业级安全合规

### 下一步学习

- 📗 **数据变换层**：Pipeline Builder、SQL、Code Repositories
- 📘 **分析层**：Contour、Quiver、Data Lineage
- 📙 **应用层**：Workshop、Notepad、Object Explorer
- 📕 **AI层**：AIP Logic、AIP Agents、MLOps

---


在 Palantir Foundry 中，增量转换 (Incremental Transforms) 是一种优化数据管道性能的关键技术。根据 Palantir Developers 发布的视频教程，以下是关于如何在 Code Repositories 中编写和管理增量数据转换的详细介绍：
1. 为什么要使用增量转换？
在处理大规模数据（如 TB 或 PB 级别）时，全量重新计算不仅在计算资源上极其昂贵，还会导致用户在漫长的计算过程中只能看到陈旧的数据。 增量转换的核心理念是： 如果历史代码没有变更，且数据集已有大量历史数据，当新数据（例如 100 万行新数据）进入时，只计算这部分新数据，而不是重新计算整个历史管道。这可以将计算时间缩短至几秒钟，从而更快地为用户提供新数据。
2. 基本原理与设置
增量转换在技术上通过代码中的注解 (annotation) 来实现。Foundry 会检测数据集中是否存在新的事务 (transactions)，并仅对这些新文件进行计算。
• 设置方法： 在转换逻辑中添加增量注解（具体可查阅文档中的 incremental 关键字）。
• 验证方式： 为了验证增量构建的效果，可以在代码中添加一个处理时间戳 (process timestamp) 列。如果是全量构建，所有行的时间戳会更新为当前时间；如果是增量构建，只有新行的时间戳会是最新时间，旧行保持不变。
3. 事务类型与增量行为
增量转换的行为取决于数据是如何进入数据集的（即事务的类型）：
• 追加事务 (Append Transaction) - 保持增量性： 当你上传一个文件名不同的新文件（例如从 transactions.csv 到 transactions2.csv）时，系统会生成一个“追加事务”,。
    ◦ 结果： 构建时，仅处理这个新文件。旧数据的处理时间戳保持不变，只有新数据行拥有最新的处理时间戳。
• 更新事务 (Update Transaction) - 失效增量性： 如果你上传一个与现有文件同名的文件（即使内容更新了），系统会将其视为“更新事务”，即替换原有文件。
    ◦ 结果： 替换文件会使该文件的增量性失效，并强制重新计算。如果你重新上传已存在的文件（即“更新”它），整个数据集可能会被强制重新计算，导致所有行的处理时间戳都更新为当前构建时间。
4. 代码逻辑变更与增量构建
仅仅修改转换代码（例如添加新列或新逻辑）并点击构建，不会自动更新已经计算过的旧数据。
• 现象： 如果你添加了一个新列并构建，该逻辑只会应用到新进入的数据行上。旧数据行在该新列中将显示为 null（空值），因为它们没有被重新计算。
5. 如何强制全量重算 (Semantic Versioning)
当你更改了代码逻辑（例如添加新列）并希望将其应用到所有历史数据时，你需要强制管道进行一次非增量的全量构建。
• 解决方案： 使用增量装饰器中的 semantic_version (语义版本) 参数。
• 操作： 该参数默认值通常为 0 或空。通过提升这个版本号（例如从 1 改为 2），你告诉 Foundry 代码发生了重大变化。
• 结果： 这将强制整个数据集重新计算，新逻辑（如新列）将应用到所有的历史事务和新事务中。
总结
在 Foundry 中编写增量转换时，关键在于理解文件事务与代码版本之间的关系：
• 新文件 (不同名) = 触发增量计算，只算新数据。
• 替换文件 (同名) = 触发重算，失效增量性。
• 修改代码逻辑 = 默认只对未来数据生效。
• 提升 semantic_version = 强制全量重算历史数据。

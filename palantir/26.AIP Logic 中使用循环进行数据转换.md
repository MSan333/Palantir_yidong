在 Palantir Foundry 的 **AIP Logic** 中，**Looping（循环）** 功能是控制流（Control Flow）模块的核心组件，专门用于对列表中的每个元素执行批量的自动化处理。

以下是关于在 AIP Logic 中使用循环进行数据转换（Transformations）的详细介绍：

### 1. 核心机制与输入要求
*   **处理逻辑：** 循环允许开发者摄取一个列表，并针对列表中的每一个元素运行一系列逻辑块（如大语言模型推理、语义搜索或数据清洗），从而实现逐行转换 [1], [2]。
*   **输入类型：** 循环必须作用于 **List（列表）** 类型。在 AIP Logic 中，最常见的做法是先定义一个 **Array（数组）** 输入，然后系统会自动调用 **"Array to literal list"** 块将其转换为可遍历的字面量列表 [3], [4], [5]。
*   **元素定义：** 在循环内部，你可以重命名当前处理的元素（Element）或索引（Index）。例如，如果你在处理动物数组，可以将元素重命名为“animal”，这不仅提高了逻辑的可读性，也方便在后续步骤中引用该变量 [6], [7]。

### 2. 循环内的转换能力
循环体内部就像一个**微型 AIP Logic 函数**，支持嵌套多种高性能模块：
*   **Use LLM（使用大模型）：** 这是最常见的用途。你可以针对每个元素编写特定的提示词（Prompt）。例如，给出一个动物名称，要求模型仅返回其对应的“属名（Genus）” [8], [9]。
*   **语义搜索（Semantic Search）：** 如果循环的每一个元素都是一个查询词，你可以在循环内为每个元素执行语义搜索，从知识库中提取相关信息 [6]。
*   **本体操作（Ontology Operations）：** 除了纯粹的数据转换，循环还可以配置为在每次迭代中执行本体编辑，如根据数组内容批量创建或修改对象 [10], [2]。
*   **多级嵌套：** 循环内部甚至可以再包含另一个控制流块（如条件判断或二级循环），以处理极其复杂的业务逻辑 [6], [7]。

### 3. 为什么选择循环而非数组处理？
尽管 LLM 有时能一次性处理整个数组，但使用循环具有显著优势：
*   **性能一致性：** 随着任务复杂度和列表长度的增加，LLM 在一次性处理大量数据时可能会出现**性能下降或结果不一致**。循环确保每个元素都能获得模型完整的注意力和处理精度 [11]。
*   **兼容性：** 许多底层转换插件和操作是针对**单一值**设计的。通过循环，你可以让这些原本不支持数组的操作灵活地应用于批量数据 [11]。
*   **结果结构化：** 循环运行结束后，会根据内部定义的输出（如字符串、数组或对象）返回一个整齐的**响应列表** [8], [3]。

### 4. 实施流程示例
1.  **定义输入：** 创建一个 `String Array`（字符串数组）作为函数的起始输入 [4]。
2.  **配置循环：** 添加 `Loop` 块并选择该数组，系统会自动生成 `Array to literal list` 转换 [4], [12]。
3.  **编写转换逻辑：** 在循环内添加 `Use LLM` 块，在任务提示词中通过正斜杠（`/`）引用“animal”元素变量 [9]。
4.  **发布与集成：** 保存并发布函数，将其绑定到本体中，随后即可在 **Workshop** 应用程序中通过按钮或变量实时调用此循环逻辑 [11], [13]。

通过这种方式，AIP Logic 将复杂的**指令性批处理**转化为直观的视觉流，使得处理非结构化列表数据变得高效且易于维护。
